0000000000001e2c <read_six_numbers>:
    1e2c:	f3 0f 1e fa          	endbr64 
    1e30:	48 83 ec 08          	sub    $0x8,%rsp # minus 0x8 from stack pointer
    
    1e34:	48 89 f2             	mov    %rsi,%rdx # 3th arg
    1e37:	48 8d 4e 04          	lea    0x4(%rsi),%rcx # 4th arg
    1e3b:	48 8d 46 14          	lea    0x14(%rsi),%rax # return val?

    1e3f:	50                   	push   %rax # put rax onto the stack, stack inceases by 8
    1e40:	48 8d 46 10          	lea    0x10(%rsi),%rax
    1e44:	50                   	push   %rax # put rax onto the stack again stack inceases by 8 again
    # the stack now is 16 longer than before

    1e45:	4c 8d 4e 0c          	lea    0xc(%rsi),%r9 # 6th arg
    1e49:	4c 8d 46 08          	lea    0x8(%rsi),%r8 # 5th arg
    1e4d:	48 8d 35 ad 15 00 00 	lea    0x15ad(%rip),%rsi        # 3401 <array.0+0x221>

    # 0x3402: "d %d %d %d %d %d"
    1e54:	b8 00 00 00 00       	mov    $0x0,%eax
    1e59:	e8 b2 f4 ff ff       	callq  1310 <__isoc99_sscanf@plt>

    1e5e:	48 83 c4 10          	add    $0x10,%rsp # add 16 to stack pointer
    # discards the information from the two pushes from before?

    1e62:	83 f8 05             	cmp    $0x5,%eax
    1e65:	7e 05                	jle    1e6c <read_six_numbers+0x40> # if the numbers read is less than 5
    # jump to 0x1e6c to explode the bomb

    1e67:	48 83 c4 08          	add    $0x8,%rsp # add 8 to stack pointer
    # remove the memory allocated at the 1e30

    1e6b:	c3                   	retq   
    1e6c:	e8 79 ff ff ff       	callq  1dea <explode_bomb>